{
	"name": "RuntimeJobFailureError",
	"message": "'Unable to retrieve job result. Circuits do not match the target definition (non-ISA circuits). -- \\\\n        
    Transpile your circuits for the target before submitting a primitive query. 
    For example, you can use the following code block given an IBMBackend object `backend`\\\\n
    and circuits of type `List[QuantumCircuit]`:\\\\n        

    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\\\\n            
    pm = generate_preset_pass_manager(optimization_level=1, target=backend.target)\\\\n            
    isa_circuits = pm.run(circuits)\\\\n        
    
    Then pass `isa_circuits` to the Sampler or Estimator.\\\\n         
    -- https://ibm.biz/error_codes#1517'",
	"stack": "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n\u001b[0;31mRuntimeJobFailureError\u001b[0m                    
    Traceback (most recent call last)\nCell \u001b[0;32mIn[58], line 10\u001b[0m\n\u001b[1;32m      
    8\u001b[0m \u001b[38;5;66;03m# Define a cost function, flipping the sign so that the optimizer maximizes the expectation value\u001b[39;00m\n\u001b[1;32m      
    9\u001b[0m cost_func \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mlambda\u001b[39;00m params: estimator\u001b[38;5;241m.\u001b[39mrun(ansatz, choc_op, parameter_values\u001b[38;5;241m=\u001b[39mparams)\u001b[38;5;241m.\u001b[39mresult()\u001b[38;5;241m.\u001b[39mvalues[\u001b[38;5;241m0\u001b[39m] \u001b[38;5;241m*\u001b[39m \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m\n\u001b[0;32m---> 10\u001b[0m result \u001b[38;5;241m=\u001b[39m \u001b[43moptimizer\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mminimize\u001b[49m\u001b[43m(\u001b[49m\u001b[43mcost_func\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mx0\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mnp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mzeros\u001b[49m\u001b[43m(\u001b[49m\u001b[43mansatz\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mnum_parameters\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n\nFile \u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/qiskit_algorithms/optimizers/spsa.py:515\u001b[0m, in \u001b[0;36mSPSA.minimize\u001b[0;34m(self, fun, x0, jac, bounds)\u001b[0m\n\u001b[1;32m    513\u001b[0m x0 \u001b[38;5;241m=\u001b[39m np\u001b[38;5;241m.\u001b[39masarray(x0)\n\u001b[1;32m    514\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mlearning_rate \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mperturbation \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m--> 515\u001b[0m     get_eta, get_eps \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcalibrate\u001b[49m\u001b[43m(\u001b[49m\u001b[43mfun\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mx0\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmax_evals_grouped\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_max_evals_grouped\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    516\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    517\u001b[0m     get_eta, get_eps \u001b[38;5;241m=\u001b[39m _validate_pert_and_learningrate(\n\u001b[1;32m    518\u001b[0m         \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mperturbation, \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mlearning_rate\n\u001b[1;32m    519\u001b[0m     )\n\nFile \u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/qiskit_algorithms/optimizers/spsa.py:335\u001b[0m, in \u001b[0;36mSPSA.calibrate\u001b[0;34m(loss, initial_point, c, stability_constant, target_magnitude, alpha, gamma, modelspace, max_evals_grouped)\u001b[0m\n\u001b[1;32m    332\u001b[0m     pert \u001b[38;5;241m=\u001b[39m bernoulli_perturbation(dim)\n\u001b[1;32m    333\u001b[0m     points \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m [initial_point \u001b[38;5;241m+\u001b[39m c \u001b[38;5;241m*\u001b[39m pert, initial_point \u001b[38;5;241m-\u001b[39m c \u001b[38;5;241m*\u001b[39m pert]\n\u001b[0;32m--> 335\u001b[0m losses \u001b[38;5;241m=\u001b[39m \u001b[43m_batch_evaluate\u001b[49m\u001b[43m(\u001b[49m\u001b[43mloss\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mpoints\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmax_evals_grouped\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    337\u001b[0m avg_magnitudes \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m0.0\u001b[39m\n\u001b[1;32m    338\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m i \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(steps):\n\nFile \u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/qiskit_algorithms/optimizers/spsa.py:694\u001b[0m, in \u001b[0;36m_batch_evaluate\u001b[0;34m(function, points, max_evals_grouped, unpack_points)\u001b[0m\n\u001b[1;32m    690\u001b[0m \u001b[38;5;66;03m# if the function cannot handle lists of points as input, cover this case immediately\u001b[39;00m\n\u001b[1;32m    691\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m max_evals_grouped \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;129;01mor\u001b[39;00m max_evals_grouped \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[1;32m    692\u001b[0m     \u001b[38;5;66;03m# support functions with multiple arguments where the points are given in a tuple\u001b[39;00m\n\u001b[1;32m    693\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m [\n\u001b[0;32m--> 694\u001b[0m         function(\u001b[38;5;241m*\u001b[39mpoint) \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(point, \u001b[38;5;28mtuple\u001b[39m) \u001b[38;5;28;01melse\u001b[39;00m \u001b[43mfunction\u001b[49m\u001b[43m(\u001b[49m\u001b[43mpoint\u001b[49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mfor\u001b[39;00m point \u001b[38;5;129;01min\u001b[39;00m points\n\u001b[1;32m    695\u001b[0m     ]\n\u001b[1;32m    697\u001b[0m num_points \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlen\u001b[39m(points)\n\u001b[1;32m    699\u001b[0m \u001b[38;5;66;03m# get the number of batches\u001b[39;00m\n\nCell \u001b[0;32mIn[58], line 9\u001b[0m, in \u001b[0;36m<lambda>\u001b[0;34m(params)\u001b[0m\n\u001b[1;32m      6\u001b[0m optimizer \u001b[38;5;241m=\u001b[39m SPSA(callback\u001b[38;5;241m=\u001b[39mcallback, maxiter\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m800\u001b[39m)\n\u001b[1;32m      8\u001b[0m \u001b[38;5;66;03m# Define a cost function, flipping the sign so that the optimizer maximizes the expectation value\u001b[39;00m\n\u001b[0;32m----> 9\u001b[0m cost_func \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mlambda\u001b[39;00m params: \u001b[43mestimator\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mrun\u001b[49m\u001b[43m(\u001b[49m\u001b[43mansatz\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mchoc_op\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mparameter_values\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mparams\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mresult\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241m.\u001b[39mvalues[\u001b[38;5;241m0\u001b[39m] \u001b[38;5;241m*\u001b[39m \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m\n\u001b[1;32m     10\u001b[0m result \u001b[38;5;241m=\u001b[39m optimizer\u001b[38;5;241m.\u001b[39mminimize(cost_func, x0\u001b[38;5;241m=\u001b[39mnp\u001b[38;5;241m.\u001b[39mzeros(ansatz\u001b[38;5;241m.\u001b[39mnum_parameters))\n\nFile \u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/qiskit_ibm_runtime/runtime_job.py:160\u001b[0m, in \u001b[0;36mRuntimeJob.result\u001b[0;34m(self, timeout, decoder)\u001b[0m\n\u001b[1;32m    158\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_reason \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mRAN TOO LONG\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[1;32m    159\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m RuntimeJobMaxTimeoutError(error_message)\n\u001b[0;32m--> 160\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m RuntimeJobFailureError(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mUnable to retrieve job result. \u001b[39m\u001b[38;5;132;01m{\u001b[39;00merror_message\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m    161\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_status \u001b[38;5;129;01mis\u001b[39;00m JobStatus\u001b[38;5;241m.\u001b[39mCANCELLED:\n\u001b[1;32m    162\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m RuntimeInvalidStateError(\n\u001b[1;32m    163\u001b[0m         \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mUnable to retrieve result for job \u001b[39m\u001b[38;5;132;01m{}\u001b[39;00m\u001b[38;5;124m. \u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mJob was cancelled.\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m.\u001b[39mformat(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mjob_id())\n\u001b[1;32m    164\u001b[0m     )\n\n\u001b[0;31mRuntimeJobFailureError\u001b[0m: 'Unable to retrieve job result. Circuits do not match the target definition (non-ISA circuits). -- \\\\n        Transpile your circuits for the target before submitting a primitive query. For\\\\n        example, you can use the following code block given an IBMBackend object `backend`\\\\n        and circuits of type `List[QuantumCircuit]`:\\\\n            from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\\\\n            pm = generate_preset_pass_manager(optimization_level=1, target=backend.target)\\\\n            isa_circuits = pm.run(circuits)\\\\n        Then pass `isa_circuits` to the Sampler or Estimator.\\\\n         -- https://ibm.biz/error_codes#1517'"
}